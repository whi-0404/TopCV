{"ast":null,"code":"import { invariant, millisecondsToSeconds, secondsToMilliseconds, noop } from 'motion-utils';\nimport { style } from '../render/dom/style.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { hydrateKeyframes } from './keyframes/hydrate.mjs';\nimport { startWaapiAnimation } from './waapi/start-waapi-animation.mjs';\nimport { applyGeneratorOptions } from './waapi/utils/apply-generator.mjs';\nconst animationMaps = new WeakMap();\nconst animationMapKey = (name, pseudoElement) => `${name}:${pseudoElement}`;\nfunction getAnimationMap(element) {\n  const map = animationMaps.get(element) || new Map();\n  animationMaps.set(element, map);\n  return map;\n}\n/**\r\n * NativeAnimation implements AnimationPlaybackControls for the browser's Web Animations API.\r\n */\nclass NativeAnimation {\n  constructor(options) {\n    /**\r\n     * If we already have an animation, we don't need to instantiate one\r\n     * and can just use this as a controls interface.\r\n     */\n    if (\"animation\" in options) {\n      this.animation = options.animation;\n      return;\n    }\n    const {\n      element,\n      name,\n      keyframes: unresolvedKeyframes,\n      pseudoElement,\n      allowFlatten = false\n    } = options;\n    let {\n      transition\n    } = options;\n    this.allowFlatten = allowFlatten;\n    /**\r\n     * Stop any existing animations on the element before reading existing keyframes.\r\n     *\r\n     * TODO: Check for VisualElement before using animation state. This is a fallback\r\n     * for mini animate(). Do this when implementing NativeAnimationExtended.\r\n     */\n    const animationMap = getAnimationMap(element);\n    const key = animationMapKey(name, pseudoElement || \"\");\n    const currentAnimation = animationMap.get(key);\n    currentAnimation && currentAnimation.stop();\n    /**\r\n     * TODO: If these keyframes aren't correctly hydrated then we want to throw\r\n     * run an instant animation.\r\n     */\n    const keyframes = hydrateKeyframes(element, name, unresolvedKeyframes, pseudoElement);\n    invariant(typeof transition.type !== \"string\", `animateMini doesn't support \"type\" as a string. Did you mean to import { spring } from \"motion\"?`);\n    transition = applyGeneratorOptions(transition);\n    this.animation = startWaapiAnimation(element, name, keyframes, transition, pseudoElement);\n    if (transition.autoplay === false) {\n      this.animation.pause();\n    }\n    this.removeAnimation = () => animationMap.delete(key);\n    this.animation.onfinish = () => {\n      if (!pseudoElement) {\n        style.set(element, name, getFinalKeyframe(keyframes, transition));\n      } else {\n        this.commitStyles();\n      }\n      this.cancel();\n    };\n    /**\r\n     * TODO: Check for VisualElement before using animation state.\r\n     */\n    animationMap.set(key, this);\n  }\n  play() {\n    this.animation.play();\n  }\n  pause() {\n    this.animation.pause();\n  }\n  complete() {\n    this.animation.finish();\n  }\n  cancel() {\n    try {\n      this.animation.cancel();\n    } catch (e) {}\n    this.removeAnimation();\n  }\n  stop() {\n    const {\n      state\n    } = this;\n    if (state === \"idle\" || state === \"finished\") {\n      return;\n    }\n    this.commitStyles();\n    this.cancel();\n  }\n  /**\r\n   * WAAPI doesn't natively have any interruption capabilities.\r\n   *\r\n   * In this method, we commit styles back to the DOM before cancelling\r\n   * the animation.\r\n   *\r\n   * This is designed to be overridden by NativeAnimationExtended, which\r\n   * will create a renderless JS animation and sample it twice to calculate\r\n   * its current value, \"previous\" value, and therefore allow\r\n   * Motion to also correctly calculate velocity for any subsequent animation\r\n   * while deferring the commit until the next animation frame.\r\n   */\n  commitStyles() {\n    this.animation.commitStyles?.();\n  }\n  get duration() {\n    console.log(this.animation.effect?.getComputedTiming());\n    const duration = this.animation.effect?.getComputedTiming().duration || 0;\n    return millisecondsToSeconds(Number(duration));\n  }\n  get time() {\n    return millisecondsToSeconds(Number(this.animation.currentTime) || 0);\n  }\n  set time(newTime) {\n    this.animation.currentTime = secondsToMilliseconds(newTime);\n  }\n  /**\r\n   * The playback speed of the animation.\r\n   * 1 = normal speed, 2 = double speed, 0.5 = half speed.\r\n   */\n  get speed() {\n    return this.animation.playbackRate;\n  }\n  set speed(newSpeed) {\n    this.animation.playbackRate = newSpeed;\n  }\n  get state() {\n    return this.animation.playState;\n  }\n  get startTime() {\n    return Number(this.animation.startTime);\n  }\n  get finished() {\n    return this.animation.finished;\n  }\n  flatten() {\n    if (this.allowFlatten) {\n      this.animation.effect?.updateTiming({\n        easing: \"linear\"\n      });\n    }\n  }\n  /**\r\n   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.\r\n   */\n  attachTimeline(timeline) {\n    this.animation.timeline = timeline;\n    this.animation.onfinish = null;\n    return noop;\n  }\n  /**\r\n   * Allows the animation to be awaited.\r\n   *\r\n   * @deprecated Use `finished` instead.\r\n   */\n  then(onResolve, onReject) {\n    return this.finished.then(onResolve).catch(onReject);\n  }\n}\nexport { NativeAnimation };","map":{"version":3,"names":["invariant","millisecondsToSeconds","secondsToMilliseconds","noop","style","getFinalKeyframe","hydrateKeyframes","startWaapiAnimation","applyGeneratorOptions","animationMaps","WeakMap","animationMapKey","name","pseudoElement","getAnimationMap","element","map","get","Map","set","NativeAnimation","constructor","options","animation","keyframes","unresolvedKeyframes","allowFlatten","transition","animationMap","key","currentAnimation","stop","type","autoplay","pause","removeAnimation","delete","onfinish","commitStyles","cancel","play","complete","finish","e","state","duration","console","log","effect","getComputedTiming","Number","time","currentTime","newTime","speed","playbackRate","newSpeed","playState","startTime","finished","flatten","updateTiming","easing","attachTimeline","timeline","then","onResolve","onReject","catch"],"sources":["D:/UIT/ThucHanhJava/FE-DO-AN/TopCV/node_modules/motion-dom/dist/es/animation/NativeAnimation.mjs"],"sourcesContent":["import { invariant, millisecondsToSeconds, secondsToMilliseconds, noop } from 'motion-utils';\r\nimport { style } from '../render/dom/style.mjs';\r\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\r\nimport { hydrateKeyframes } from './keyframes/hydrate.mjs';\r\nimport { startWaapiAnimation } from './waapi/start-waapi-animation.mjs';\r\nimport { applyGeneratorOptions } from './waapi/utils/apply-generator.mjs';\r\n\r\nconst animationMaps = new WeakMap();\r\nconst animationMapKey = (name, pseudoElement) => `${name}:${pseudoElement}`;\r\nfunction getAnimationMap(element) {\r\n    const map = animationMaps.get(element) || new Map();\r\n    animationMaps.set(element, map);\r\n    return map;\r\n}\r\n/**\r\n * NativeAnimation implements AnimationPlaybackControls for the browser's Web Animations API.\r\n */\r\nclass NativeAnimation {\r\n    constructor(options) {\r\n        /**\r\n         * If we already have an animation, we don't need to instantiate one\r\n         * and can just use this as a controls interface.\r\n         */\r\n        if (\"animation\" in options) {\r\n            this.animation = options.animation;\r\n            return;\r\n        }\r\n        const { element, name, keyframes: unresolvedKeyframes, pseudoElement, allowFlatten = false, } = options;\r\n        let { transition } = options;\r\n        this.allowFlatten = allowFlatten;\r\n        /**\r\n         * Stop any existing animations on the element before reading existing keyframes.\r\n         *\r\n         * TODO: Check for VisualElement before using animation state. This is a fallback\r\n         * for mini animate(). Do this when implementing NativeAnimationExtended.\r\n         */\r\n        const animationMap = getAnimationMap(element);\r\n        const key = animationMapKey(name, pseudoElement || \"\");\r\n        const currentAnimation = animationMap.get(key);\r\n        currentAnimation && currentAnimation.stop();\r\n        /**\r\n         * TODO: If these keyframes aren't correctly hydrated then we want to throw\r\n         * run an instant animation.\r\n         */\r\n        const keyframes = hydrateKeyframes(element, name, unresolvedKeyframes, pseudoElement);\r\n        invariant(typeof transition.type !== \"string\", `animateMini doesn't support \"type\" as a string. Did you mean to import { spring } from \"motion\"?`);\r\n        transition = applyGeneratorOptions(transition);\r\n        this.animation = startWaapiAnimation(element, name, keyframes, transition, pseudoElement);\r\n        if (transition.autoplay === false) {\r\n            this.animation.pause();\r\n        }\r\n        this.removeAnimation = () => animationMap.delete(key);\r\n        this.animation.onfinish = () => {\r\n            if (!pseudoElement) {\r\n                style.set(element, name, getFinalKeyframe(keyframes, transition));\r\n            }\r\n            else {\r\n                this.commitStyles();\r\n            }\r\n            this.cancel();\r\n        };\r\n        /**\r\n         * TODO: Check for VisualElement before using animation state.\r\n         */\r\n        animationMap.set(key, this);\r\n    }\r\n    play() {\r\n        this.animation.play();\r\n    }\r\n    pause() {\r\n        this.animation.pause();\r\n    }\r\n    complete() {\r\n        this.animation.finish();\r\n    }\r\n    cancel() {\r\n        try {\r\n            this.animation.cancel();\r\n        }\r\n        catch (e) { }\r\n        this.removeAnimation();\r\n    }\r\n    stop() {\r\n        const { state } = this;\r\n        if (state === \"idle\" || state === \"finished\") {\r\n            return;\r\n        }\r\n        this.commitStyles();\r\n        this.cancel();\r\n    }\r\n    /**\r\n     * WAAPI doesn't natively have any interruption capabilities.\r\n     *\r\n     * In this method, we commit styles back to the DOM before cancelling\r\n     * the animation.\r\n     *\r\n     * This is designed to be overridden by NativeAnimationExtended, which\r\n     * will create a renderless JS animation and sample it twice to calculate\r\n     * its current value, \"previous\" value, and therefore allow\r\n     * Motion to also correctly calculate velocity for any subsequent animation\r\n     * while deferring the commit until the next animation frame.\r\n     */\r\n    commitStyles() {\r\n        this.animation.commitStyles?.();\r\n    }\r\n    get duration() {\r\n        console.log(this.animation.effect?.getComputedTiming());\r\n        const duration = this.animation.effect?.getComputedTiming().duration || 0;\r\n        return millisecondsToSeconds(Number(duration));\r\n    }\r\n    get time() {\r\n        return millisecondsToSeconds(Number(this.animation.currentTime) || 0);\r\n    }\r\n    set time(newTime) {\r\n        this.animation.currentTime = secondsToMilliseconds(newTime);\r\n    }\r\n    /**\r\n     * The playback speed of the animation.\r\n     * 1 = normal speed, 2 = double speed, 0.5 = half speed.\r\n     */\r\n    get speed() {\r\n        return this.animation.playbackRate;\r\n    }\r\n    set speed(newSpeed) {\r\n        this.animation.playbackRate = newSpeed;\r\n    }\r\n    get state() {\r\n        return this.animation.playState;\r\n    }\r\n    get startTime() {\r\n        return Number(this.animation.startTime);\r\n    }\r\n    get finished() {\r\n        return this.animation.finished;\r\n    }\r\n    flatten() {\r\n        if (this.allowFlatten) {\r\n            this.animation.effect?.updateTiming({ easing: \"linear\" });\r\n        }\r\n    }\r\n    /**\r\n     * Attaches a timeline to the animation, for instance the `ScrollTimeline`.\r\n     */\r\n    attachTimeline(timeline) {\r\n        this.animation.timeline = timeline;\r\n        this.animation.onfinish = null;\r\n        return noop;\r\n    }\r\n    /**\r\n     * Allows the animation to be awaited.\r\n     *\r\n     * @deprecated Use `finished` instead.\r\n     */\r\n    then(onResolve, onReject) {\r\n        return this.finished.then(onResolve).catch(onReject);\r\n    }\r\n}\r\n\r\nexport { NativeAnimation };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}