#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Script t·ª± ƒë·ªông test API Job Recommendation System
Thay th·∫ø cho vi·ªác test th·ªß c√¥ng b·∫±ng Postman
"""

import requests
import json
import time
import os
from pathlib import Path

BASE_URL = "http://localhost:8000"

def print_header(title):
    """In header ƒë·∫πp cho t·ª´ng test"""
    print(f"\n{'='*60}")
    print(f"üß™ {title}")
    print(f"{'='*60}")

def print_response(response, title="Response"):
    """In response m·ªôt c√°ch ƒë·∫πp m·∫Øt"""
    print(f"\nüìã {title}:")
    print(f"Status Code: {response.status_code}")
    try:
        if response.headers.get('content-type', '').startswith('application/json'):
            print(f"Response: {json.dumps(response.json(), indent=2, ensure_ascii=False)}")
        else:
            print(f"Response: {response.text}")
    except:
        print(f"Response: {response.text}")

def test_health_check():
    """Test 1: Health Check"""
    print_header("TEST 1: HEALTH CHECK")
    
    try:
        response = requests.get(f"{BASE_URL}/health")
        print_response(response)
        
        if response.status_code == 200:
            print("‚úÖ Health check PASSED")
            return True
        else:
            print("‚ùå Health check FAILED")
            return False
    except Exception as e:
        print(f"‚ùå Health check ERROR: {e}")
        return False

def test_upload_jobs():
    """Test 2: Upload Jobs"""
    print_header("TEST 2: UPLOAD JOBS")
    
    # Sample jobs data
    jobs = [
        {
            "job_data": {
                "job_id": "JOB001",
                "job_title": "Python Backend Developer",
                "company": "TechCorp Vietnam",
                "location": "H√† N·ªôi",
                "job_type": "Full-time",
                "required_skills": ["Python", "Django", "PostgreSQL", "REST API", "Docker"],
                "min_experience": 2,
                "education_requirement": "ƒê·∫°i h·ªçc",
                "job_description": "Ch√∫ng t√¥i ƒëang t√¨m ki·∫øm m·ªôt Python Backend Developer c√≥ kinh nghi·ªám ƒë·ªÉ tham gia v√†o ƒë·ªôi ng≈© ph√°t tri·ªÉn c√°c ·ª©ng d·ª•ng web quy m√¥ l·ªõn. ·ª®ng vi√™n s·∫Ω l√†m vi·ªác v·ªõi Django framework, thi·∫øt k·∫ø API, v√† t·ªëi ∆∞u h√≥a performance.",
                "responsibilities": [
                    "Ph√°t tri·ªÉn v√† maintain c√°c API backend s·ª≠ d·ª•ng Python/Django",
                    "Thi·∫øt k·∫ø database v√† optimize queries",
                    "T√≠ch h·ª£p v·ªõi c√°c d·ªãch v·ª• th·ª© ba",
                    "Code review v√† mentoring junior developers",
                    "Implement security best practices"
                ],
                "benefits": [
                    "L∆∞∆°ng c·∫°nh tranh 15-25 tri·ªáu",
                    "B·∫£o hi·ªÉm s·ª©c kh·ªèe",
                    "13th month salary",
                    "Training v√† ph√°t tri·ªÉn k·ªπ nƒÉng",
                    "Work from home 2 ng√†y/tu·∫ßn"
                ]
            }
        },
        {
            "job_data": {
                "job_id": "JOB002", 
                "job_title": "React Frontend Developer",
                "company": "StartupXYZ",
                "location": "H·ªì Ch√≠ Minh",
                "job_type": "Full-time",
                "required_skills": ["React", "JavaScript", "TypeScript", "HTML/CSS", "Redux"],
                "min_experience": 1,
                "education_requirement": "Cao ƒë·∫≥ng",
                "job_description": "Tham gia ph√°t tri·ªÉn giao di·ªán ng∆∞·ªùi d√πng cho c√°c ·ª©ng d·ª•ng web hi·ªán ƒë·∫°i. L√†m vi·ªác v·ªõi React, TypeScript v√† c√°c c√¥ng ngh·ªá frontend ti√™n ti·∫øn nh·∫•t.",
                "responsibilities": [
                    "Ph√°t tri·ªÉn UI components s·ª≠ d·ª•ng React/TypeScript",
                    "T·ªëi ∆∞u performance v√† user experience",
                    "Collaborate v·ªõi UX/UI designers",
                    "Maintain code quality v√† best practices",
                    "Unit testing v√† integration testing"
                ],
                "benefits": [
                    "L∆∞∆°ng 12-20 tri·ªáu",
                    "M√¥i tr∆∞·ªùng startup nƒÉng ƒë·ªông",
                    "Flexible working hours",
                    "Team building h√†ng th√°ng",
                    "Learning budget"
                ]
            }
        },
        {
            "job_data": {
                "job_id": "JOB003",
                "job_title": "Full Stack Developer",
                "company": "Digital Agency ABC",
                "location": "ƒê√† N·∫µng", 
                "job_type": "Full-time",
                "required_skills": ["Node.js", "React", "MongoDB", "Express", "AWS"],
                "min_experience": 3,
                "education_requirement": "ƒê·∫°i h·ªçc",
                "job_description": "V·ªã tr√≠ Full Stack Developer ƒë·ªÉ ph√°t tri·ªÉn c√°c d·ª± √°n web application t·ª´ frontend ƒë·∫øn backend. L√†m vi·ªác v·ªõi MERN stack v√† cloud services.",
                "responsibilities": [
                    "Ph√°t tri·ªÉn end-to-end web applications",
                    "Database design v√† API development",
                    "Deploy v√† manage applications tr√™n cloud",
                    "Technical consultation cho clients",
                    "Lead technical projects"
                ],
                "benefits": [
                    "L∆∞∆°ng 18-30 tri·ªáu",
                    "Project bonus",
                    "Du l·ªãch company h√†ng nƒÉm",
                    "Laptop v√† thi·∫øt b·ªã l√†m vi·ªác",
                    "Remote work option"
                ]
            }
        }
    ]
    
    success_count = 0
    
    for i, job in enumerate(jobs, 1):
        print(f"\nüì§ Uploading Job {i}: {job['job_data']['job_title']}")
        
        try:
            response = requests.post(
                f"{BASE_URL}/jobs/upload",
                json=job,
                headers={"Content-Type": "application/json"}
            )
            
            if response.status_code == 200:
                print(f"‚úÖ Job {i} uploaded successfully")
                success_count += 1
            else:
                print(f"‚ùå Job {i} upload failed")
                print_response(response)
                
        except Exception as e:
            print(f"‚ùå Job {i} upload ERROR: {e}")
    
    print(f"\nüìä Jobs upload summary: {success_count}/{len(jobs)} successful")
    return success_count == len(jobs)

def test_get_jobs():
    """Test 3: Get Jobs"""
    print_header("TEST 3: GET JOBS")
    
    try:
        response = requests.get(f"{BASE_URL}/jobs")
        print_response(response)
        
        if response.status_code == 200:
            data = response.json()
            job_count = len(data.get('jobs', []))
            print(f"‚úÖ Found {job_count} jobs")
            return job_count > 0
        else:
            print("‚ùå Get jobs FAILED")
            return False
            
    except Exception as e:
        print(f"‚ùå Get jobs ERROR: {e}")
        return False

def test_cv_upload_recommendation():
    """Test 4: Upload CV v√† nh·∫≠n g·ª£i √Ω"""
    print_header("TEST 4: CV UPLOAD & RECOMMENDATION")
    
    # T√¨m file CV c√≥ s·∫µn
    cv_files = [
        "WebDeveloper_CV.pdf",
        "cv_1726397675677.pdf", 
        "cv2.pdf",
        "1.jpg"
    ]
    
    cv_file = None
    for file_name in cv_files:
        if os.path.exists(file_name):
            cv_file = file_name
            break
    
    if not cv_file:
        print("‚ùå Kh√¥ng t√¨m th·∫•y file CV ƒë·ªÉ test")
        print(f"üìÅ C·∫ßn c√≥ m·ªôt trong c√°c file sau: {cv_files}")
        return False
    
    print(f"üìÑ Using CV file: {cv_file}")
    
    try:
        with open(cv_file, 'rb') as f:
            files = {'file': (cv_file, f, 'application/octet-stream')}
            data = {
                'top_k': 5,
                'min_score': 0.1,  # Gi·∫£m min_score ƒë·ªÉ d·ªÖ c√≥ k·∫øt qu·∫£
                'location': 'H√† N·ªôi'
            }
            
            response = requests.post(
                f"{BASE_URL}/cv/upload",
                files=files,
                data=data
            )
            
        print_response(response)
        
        if response.status_code == 200:
            data = response.json()
            recommendations = data.get('recommendations', [])
            print(f"‚úÖ CV analyzed successfully, got {len(recommendations)} recommendations")
            
            if recommendations:
                print(f"üéØ Top recommendation: {recommendations[0]['job_data']['job_title']}")
                print(f"üìä Score: {recommendations[0]['overall_score']:.3f}")
            
            return True
        else:
            print("‚ùå CV upload and recommendation FAILED")
            return False
            
    except Exception as e:
        print(f"‚ùå CV upload ERROR: {e}")
        return False

def test_cv_screening():
    """Test 5: CV Screening"""
    print_header("TEST 5: CV SCREENING")
    
    # T√¨m file CV c√≥ s·∫µn
    cv_files = [
        "WebDeveloper_CV.pdf",
        "cv_1726397675677.pdf", 
        "cv2.pdf",
        "1.jpg"
    ]
    
    cv_file = None
    for file_name in cv_files:
        if os.path.exists(file_name):
            cv_file = file_name
            break
    
    if not cv_file:
        print("‚ùå Kh√¥ng t√¨m th·∫•y file CV ƒë·ªÉ test")
        return False
    
    job_id = "JOB001"  # Test v·ªõi Python Developer job
    print(f"üìÑ Using CV file: {cv_file}")
    print(f"üéØ Screening for Job ID: {job_id}")
    
    try:
        with open(cv_file, 'rb') as f:
            files = {'cv_file': (cv_file, f, 'application/octet-stream')}
            
            response = requests.post(
                f"{BASE_URL}/screening/apply-job",
                files=files,
                params={'job_id': job_id}
            )
            
        print_response(response)
        
        if response.status_code == 200:
            data = response.json()
            decision = data.get('candidate_decision', 'UNKNOWN')
            score = data.get('overall_score', 0)
            
            print(f"‚úÖ CV screening completed")
            print(f"üéØ Decision: {decision}")
            print(f"üìä Score: {score:.3f}")
            
            return True
        else:
            print("‚ùå CV screening FAILED")
            return False
            
    except Exception as e:
        print(f"‚ùå CV screening ERROR: {e}")
        return False

def main():
    """Main test function"""
    print("üöÄ Starting API Test Suite")
    print("üìç Testing API at:", BASE_URL)
    
    # Wait for server to be ready
    print("\n‚è≥ Waiting for server to be ready...")
    time.sleep(2)
    
    # Run tests
    tests = [
        ("Health Check", test_health_check),
        ("Upload Jobs", test_upload_jobs),
        ("Get Jobs", test_get_jobs),
        ("CV Upload & Recommendation", test_cv_upload_recommendation),
        ("CV Screening", test_cv_screening)
    ]
    
    results = []
    
    for test_name, test_func in tests:
        try:
            result = test_func()
            results.append((test_name, result))
            time.sleep(1)  # Delay between tests
        except Exception as e:
            print(f"‚ùå Test {test_name} crashed: {e}")
            results.append((test_name, False))
    
    # Print summary
    print_header("TEST SUMMARY")
    
    passed = 0
    total = len(results)
    
    for test_name, result in results:
        status = "‚úÖ PASSED" if result else "‚ùå FAILED"
        print(f"{status} - {test_name}")
        if result:
            passed += 1
    
    print(f"\nüìä Overall Result: {passed}/{total} tests passed")
    
    if passed == total:
        print("üéâ All tests PASSED! H·ªá th·ªëng ho·∫°t ƒë·ªông t·ªët!")
    else:
        print("‚ö†Ô∏è Some tests FAILED. Ki·ªÉm tra l·∫°i server v√† configuration.")
    
    print(f"\nüí° ƒê·ªÉ test b·∫±ng Postman, xem file: postman_test_guide.md")
    print(f"üìñ API Documentation: {BASE_URL}/docs")

if __name__ == "__main__":
    main() 